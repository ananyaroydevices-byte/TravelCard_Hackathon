import { supabase } from './supabase';

const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY;
const GEMINI_MODEL = 'gemini-3-pro-image';
const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`;

interface GeminiPart {
  text?: string;
  inlineData?: {
    mimeType: string;
    data: string;
  };
}

interface GeminiImageRequest {
  contents: Array<{
    parts: GeminiPart[];
  }>;
  generationConfig?: {
    imageConfig?: {
      aspectRatio?: string;
    };
  };
}

interface GeminiImageResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text?: string;
        inlineData?: {
          data: string;
          mimeType: string;
        };
      }>;
    };
  }>;
}

export async function generatePersonalizedDestinationImage(
  travelerPhotoUrl: string,
  destination: string,
  userId: string
): Promise<{ url: string; isAiGenerated: boolean; metadata: any }> {
  try {
    if (!GEMINI_API_KEY || GEMINI_API_KEY === 'your_gemini_api_key_here') {
      console.warn('Gemini API key not configured, falling back to stock image');
      return {
        url: '',
        isAiGenerated: false,
        metadata: { error: 'API key not configured' }
      };
    }

    console.log('üé® Starting AI image generation...');
    console.log('üìç Destination:', destination);
    console.log('üì∑ Traveler photo URL:', travelerPhotoUrl);
    console.log('ü§ñ Using model:', GEMINI_MODEL);

    console.log('‚¨áÔ∏è Downloading traveler photo...');
    const travelerImageBase64 = await downloadImageAsBase64(travelerPhotoUrl);
    console.log('‚úÖ Photo downloaded successfully');

    const prompt = buildImageEditPrompt(destination);
    console.log('üìù Generated prompt:', prompt);

    const requestBody: GeminiImageRequest = {
      contents: [{
        parts: [
          { text: prompt },
          {
            inlineData: {
              mimeType: 'image/jpeg',
              data: travelerImageBase64
            }
          }
        ]
      }],
      generationConfig: {
        imageConfig: {
          aspectRatio: '16:9'
        }
      }
    };

    console.log('üöÄ Calling Gemini API for image editing...');

    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Gemini API error response:', errorText);
      console.error('Status:', response.status, response.statusText);
      throw new Error(`Gemini API error: ${response.status} ${response.statusText}. ${errorText}`);
    }

    const result: GeminiImageResponse = await response.json();
    console.log('‚úÖ Received response from Gemini API');
    console.log('Candidates:', result.candidates?.length || 0);

    if (!result.candidates || result.candidates.length === 0) {
      console.error('‚ùå No candidates in response');
      throw new Error('No image generated by Gemini - no candidates returned');
    }

    const imagePart = result.candidates[0].content.parts.find(part => part.inlineData);
    if (!imagePart || !imagePart.inlineData) {
      console.error('‚ùå No image data in response parts');
      console.error('Response parts:', JSON.stringify(result.candidates[0].content.parts));
      throw new Error('No image data in Gemini response');
    }

    console.log('üì¶ Processing generated image...');
    const generatedImageBase64 = imagePart.inlineData.data;
    const mimeType = imagePart.inlineData.mimeType || 'image/png';
    console.log('Image MIME type:', mimeType);

    const imageBuffer = base64ToBlob(generatedImageBase64, mimeType);
    console.log('Image size:', (imageBuffer.size / 1024).toFixed(2), 'KB');

    const fileName = `${userId}/${destination.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}.jpg`;
    console.log('‚¨ÜÔ∏è Uploading to Supabase:', fileName);

    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('ai-generated-images')
      .upload(fileName, imageBuffer, {
        contentType: mimeType,
        upsert: false
      });

    if (uploadError) {
      console.error('‚ùå Upload error:', uploadError);
      throw new Error(`Failed to upload AI-generated image: ${uploadError.message}`);
    }

    const { data: urlData } = supabase.storage
      .from('ai-generated-images')
      .getPublicUrl(uploadData.path);

    console.log('‚úÖ AI image generated and uploaded successfully!');
    console.log('üåê Public URL:', urlData.publicUrl);

    return {
      url: urlData.publicUrl,
      isAiGenerated: true,
      metadata: {
        generatedAt: new Date().toISOString(),
        destination: destination,
        model: GEMINI_MODEL,
        prompt: prompt
      }
    };

  } catch (error) {
    console.error('‚ùå Error generating AI image:', error);
    if (error instanceof Error) {
      console.error('Error details:', error.message);
      console.error('Stack trace:', error.stack);
    }
    return {
      url: '',
      isAiGenerated: false,
      metadata: {
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
        destination: destination
      }
    };
  }
}

async function downloadImageAsBase64(imageUrl: string): Promise<string> {
  const response = await fetch(imageUrl);
  if (!response.ok) {
    throw new Error('Failed to download image');
  }

  const blob = await response.blob();
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      const base64String = reader.result as string;
      const base64Data = base64String.split(',')[1];
      resolve(base64Data);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

function base64ToBlob(base64: string, mimeType: string): Blob {
  const byteCharacters = atob(base64);
  const byteNumbers = new Array(byteCharacters.length);

  for (let i = 0; i < byteCharacters.length; i++) {
    byteNumbers[i] = byteCharacters.charCodeAt(i);
  }

  const byteArray = new Uint8Array(byteNumbers);
  return new Blob([byteArray], { type: mimeType });
}

function buildImageEditPrompt(destination: string): string {
  const landmarks: Record<string, string[]> = {
    'Paris': ['Eiffel Tower', 'Louvre Museum', 'Arc de Triomphe', 'Seine River'],
    'Tokyo': ['Tokyo Tower', 'Shibuya Crossing', 'Mount Fuji', 'cherry blossoms'],
    'New York': ['Statue of Liberty', 'Times Square', 'Central Park', 'Brooklyn Bridge'],
    'London': ['Big Ben', 'London Eye', 'Tower Bridge', 'Buckingham Palace'],
    'Dubai': ['Burj Khalifa', 'Palm Jumeirah', 'Dubai Marina', 'desert dunes'],
    'Rome': ['Colosseum', 'Trevi Fountain', 'Vatican City', 'Roman Forum'],
    'Barcelona': ['Sagrada Familia', 'Park G√ºell', 'La Rambla', 'Gothic Quarter'],
    'Sydney': ['Opera House', 'Harbour Bridge', 'Bondi Beach', 'Darling Harbour'],
    'Singapore': ['Marina Bay Sands', 'Gardens by the Bay', 'Sentosa Island', 'Merlion'],
    'Thailand': ['temples', 'floating markets', 'beaches', 'street markets']
  };

  const destinationLandmarks = landmarks[destination] || ['iconic landmarks', 'scenic views', 'local attractions'];
  const landmarkList = destinationLandmarks.slice(0, 2).join(' and ');

  return `Edit this photograph to show the person enjoying their vacation in ${destination}.
Place them in a natural, photorealistic scene at ${landmarkList}.
The person should appear happy and engaged, as if they are genuinely visiting this destination.
Maintain the person's appearance and features exactly as shown in the original photo.
Make the lighting, perspective, and composition look natural and professionally photographed.
The background should clearly show they are in ${destination} with recognizable landmarks or scenery.
Create a wide-angle travel photography style with the person as the main subject in the foreground.`;
}
