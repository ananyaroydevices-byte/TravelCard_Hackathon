import { supabase } from './supabase';

const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY;
const GEMINI_MODEL = 'gemini-2.5-flash-image';
const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`;

interface GeminiPart {
  text?: string;
  inlineData?: {
    mimeType: string;
    data: string;
  };
}

interface GeminiImageRequest {
  contents: Array<{
    parts: GeminiPart[];
  }>;
  generationConfig?: {
    imageConfig?: {
      aspectRatio?: string;
    };
  };
}

interface GeminiImageResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text?: string;
        inlineData?: {
          data: string;
          mimeType: string;
        };
      }>;
    };
  }>;
}

export async function generatePersonalizedDestinationImage(
  travelerPhotoUrl: string,
  destination: string,
  userId: string
): Promise<{ url: string; isAiGenerated: boolean; metadata: any }> {
  try {
    if (!GEMINI_API_KEY || GEMINI_API_KEY === 'your_gemini_api_key_here') {
      console.warn('Gemini API key not configured, falling back to stock image');
      return {
        url: '',
        isAiGenerated: false,
        metadata: { error: 'API key not configured' }
      };
    }

    console.log('Starting AI image generation for destination:', destination);

    const travelerImageBase64 = await downloadImageAsBase64(travelerPhotoUrl);
    const prompt = buildImageEditPrompt(destination);

    const requestBody: GeminiImageRequest = {
      contents: [{
        parts: [
          { text: prompt },
          {
            inlineData: {
              mimeType: 'image/jpeg',
              data: travelerImageBase64
            }
          }
        ]
      }],
      generationConfig: {
        imageConfig: {
          aspectRatio: '16:9'
        }
      }
    };

    console.log('Calling Gemini API...');

    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Gemini API error response:', errorText);
      throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
    }

    const result: GeminiImageResponse = await response.json();
    console.log('Received response from Gemini API');

    if (!result.candidates || result.candidates.length === 0) {
      throw new Error('No image generated by Gemini');
    }

    const imagePart = result.candidates[0].content.parts.find(part => part.inlineData);
    if (!imagePart || !imagePart.inlineData) {
      throw new Error('No image data in Gemini response');
    }

    const generatedImageBase64 = imagePart.inlineData.data;
    const mimeType = imagePart.inlineData.mimeType || 'image/png';

    const imageBuffer = base64ToBlob(generatedImageBase64, mimeType);

    const fileName = `${userId}/${destination.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}.jpg`;

    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('ai-generated-images')
      .upload(fileName, imageBuffer, {
        contentType: mimeType,
        upsert: false
      });

    if (uploadError) {
      throw new Error(`Failed to upload AI-generated image: ${uploadError.message}`);
    }

    const { data: urlData } = supabase.storage
      .from('ai-generated-images')
      .getPublicUrl(uploadData.path);

    console.log('AI image generated and uploaded successfully');

    return {
      url: urlData.publicUrl,
      isAiGenerated: true,
      metadata: {
        generatedAt: new Date().toISOString(),
        destination: destination,
        model: GEMINI_MODEL,
        prompt: prompt
      }
    };

  } catch (error) {
    console.error('Error generating AI image:', error);
    return {
      url: '',
      isAiGenerated: false,
      metadata: { error: error instanceof Error ? error.message : 'Unknown error' }
    };
  }
}

async function downloadImageAsBase64(imageUrl: string): Promise<string> {
  const response = await fetch(imageUrl);
  if (!response.ok) {
    throw new Error('Failed to download image');
  }

  const blob = await response.blob();
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      const base64String = reader.result as string;
      const base64Data = base64String.split(',')[1];
      resolve(base64Data);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

function base64ToBlob(base64: string, mimeType: string): Blob {
  const byteCharacters = atob(base64);
  const byteNumbers = new Array(byteCharacters.length);

  for (let i = 0; i < byteCharacters.length; i++) {
    byteNumbers[i] = byteCharacters.charCodeAt(i);
  }

  const byteArray = new Uint8Array(byteNumbers);
  return new Blob([byteArray], { type: mimeType });
}

function buildImageEditPrompt(destination: string): string {
  const landmarks: Record<string, string[]> = {
    'Paris': ['Eiffel Tower', 'Louvre Museum', 'Arc de Triomphe', 'Seine River'],
    'Tokyo': ['Tokyo Tower', 'Shibuya Crossing', 'Mount Fuji', 'cherry blossoms'],
    'New York': ['Statue of Liberty', 'Times Square', 'Central Park', 'Brooklyn Bridge'],
    'London': ['Big Ben', 'London Eye', 'Tower Bridge', 'Buckingham Palace'],
    'Dubai': ['Burj Khalifa', 'Palm Jumeirah', 'Dubai Marina', 'desert dunes'],
    'Rome': ['Colosseum', 'Trevi Fountain', 'Vatican City', 'Roman Forum'],
    'Barcelona': ['Sagrada Familia', 'Park GÃ¼ell', 'La Rambla', 'Gothic Quarter'],
    'Sydney': ['Opera House', 'Harbour Bridge', 'Bondi Beach', 'Darling Harbour'],
    'Singapore': ['Marina Bay Sands', 'Gardens by the Bay', 'Sentosa Island', 'Merlion'],
    'Thailand': ['temples', 'floating markets', 'beaches', 'street markets']
  };

  const destinationLandmarks = landmarks[destination] || ['iconic landmarks', 'scenic views', 'local attractions'];
  const landmarkList = destinationLandmarks.slice(0, 2).join(' and ');

  return `Edit this photograph to show the person enjoying their vacation in ${destination}.
Place them in a natural, photorealistic scene at ${landmarkList}.
The person should appear happy and engaged, as if they are genuinely visiting this destination.
Maintain the person's appearance and features exactly as shown in the original photo.
Make the lighting, perspective, and composition look natural and professionally photographed.
The background should clearly show they are in ${destination} with recognizable landmarks or scenery.
Create a wide-angle travel photography style with the person as the main subject in the foreground.`;
}
